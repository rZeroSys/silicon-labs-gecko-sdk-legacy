{% import "common.template" as common %}
{% set arch = context["ARCHITECTURE_ID"].split("+") %}
{% set is_arch_xg11 = ("efr32~series[1]~device_configuration[1]"|isarchcompatible(context["ARCHITECTURE_ID"])) %}
{% set is_arch_xg13 = ("efr32~series[1]~device_configuration[3]"|isarchcompatible(context["ARCHITECTURE_ID"])) %}
{% set is_arch_xg21 = ("efr32~series[2]~device_configuration[1]"|isarchcompatible(context["ARCHITECTURE_ID"])) %}
{% set is_arch_xg22 = ("efr32~series[2]~device_configuration[2]"|isarchcompatible(context["ARCHITECTURE_ID"])) %}
{% set boards = {} %}
{% set modules = {} %}
{% for d in context["CODEGEN"] %}
  {% if "boards" in d %}
    {% do boards.update(d["boards"]) %}
  {% endif %}
  {% if "modules" in d %}
    {% do modules.update(d["modules"]) %}
  {% endif %}
{% endfor %}
{% set board = arch[1]|upper %}
{% set ismodule = ("!module" not in arch[0]) %}
{% set is_part_only = (board == "NONE") %}
{% set is_chip_only = (not ismodule and is_part_only) %}
{% set series = common.getArchIdModifier(arch, "series") %}
{# 'features' is defined as a list, and while extending, there's a chance it will have duplicates,
   but this does not affect the functionality when checking for a given feature #}
{% set features = [] %}
{% if ismodule %}
  {% do features.extend( modules[ context["OPN_ID"]|upper ]["Features"] ) %}
{% endif %}
{% if is_part_only %}
  {# Default features for chips/modules of all series #}
  {% do features.extend(["S"~series~"_RTCC",
                         "S"~series~"_OSCILLATOR",
                         "S"~series~"_CMU",
                         "S"~series~"_CTUNE"]) %}
  {# series-1 has integrated DCDC #}
  {% if "1" in series or is_arch_xg22 %}
    {% do features.append("DCDC") %}
  {% endif %}
{% else %}
  {% do features.extend( boards[board]["Features"] ) %}
{% endif %}
/***************************************************************************//**
 * @file
 * @brief init_mcu.c
 *******************************************************************************
 * # License
 * <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b>
 *******************************************************************************
 *
 * The licensor of this software is Silicon Laboratories Inc. Your use of this
 * software is governed by the terms of Silicon Labs Master Software License
 * Agreement (MSLA) available at
 * www.silabs.com/about-us/legal/master-software-license-agreement. This
 * software is distributed to you in Source Code format and is governed by the
 * sections of the MSLA applicable to Source Code.
 *
 ******************************************************************************/

#if defined(HAL_CONFIG)
#include "bsphalconfig.h"
#include "hal-config.h"
#else
#include "bspconfig.h"
#endif

#include "board_features.h"

#include "em_chip.h"
#include "em_cmu.h"
#include "em_emu.h"
#include "em_rtcc.h"

#include "bsp.h"

#include "init_mcu.h"

{% if is_arch_xg11 %}
#include "tempdrv.h"
{% endif %}

// Bit [19] in MODULEINFO is the HFXOCALVAL:
// 1=No factory cal, use default XO tunning value in FW
// 0=Factory Cal, use XO tunning value in DI 
#define DEVINFO_MODULEINFO_HFXOCALVAL_MASK  0x00080000UL
// Calibration value for HFXO CTUNE is at DEVINFO Offset 0x08
#define DEVINFO_MODULEINFO_CRYSTALOSCCALVAL  (*((uint16_t *) (uint32_t)(DEVINFO_BASE+0x8UL)))
// [15:9] : (LFXOTUNING) Calibration for LFXO TUNING
// [8:0]  : (HFXOCTUNE) Calibration for HFXO CTUNE
#define DEVINFO_HFXOCTUNE_MASK  0x01FFUL

{% if "S1_CTUNE" in features %}
#define set_HFXO_CTUNE(val) do {hfxoInit.ctuneSteadyState = (val);} while (0)
{% elif "S2_CTUNE" in features %}
#define set_HFXO_CTUNE(val)         \
  do {                              \
    hfxoInit.ctuneXoAna = (val);    \
    hfxoInit.ctuneXiAna = (val);    \
  } while (0)
{% else %}
{# Can not happen: HFXO is used for BLE #}
{% endif %}

static void initMcu_clocks(void);
static void initHFXO(void);

void initMcu(void)
{
  // Device errata
  CHIP_Init();

{% if "DCDC" in features %}
  // Set up DC-DC converter
  EMU_DCDCInit_TypeDef dcdcInit = BSP_DCDC_INIT;
  #if HAL_DCDC_BYPASS
  dcdcInit.dcdcMode = emuDcdcMode_Bypass;
  #endif
  EMU_DCDCInit(&dcdcInit);

{% elif "S1_EMU" in features %}
  // Power-off DC-DC converter
  EMU_DCDCPowerOff();

{% endif %}
  // Set up clocks
  initMcu_clocks();

{% if is_arch_xg22 %}
  CMU_ClockEnable(cmuClock_RTCC, true);
{% endif %}

  RTCC_Init_TypeDef rtccInit = RTCC_INIT_DEFAULT;
  rtccInit.enable                = true;
  rtccInit.debugRun              = false;
  rtccInit.precntWrapOnCCV0      = false;
  rtccInit.cntWrapOnCCV1         = false;
  rtccInit.prescMode             = rtccCntTickPresc;
  rtccInit.presc                 = rtccCntPresc_1;
{% if "S1_RTCC" in features %}
  rtccInit.enaOSCFailDetect      = false;
  rtccInit.cntMode               = rtccCntModeNormal;
{% endif %}
  RTCC_Init(&rtccInit);

#if defined(EMU_VSCALE_PRESENT)
  // Set up EM0, EM1 energy mode configuration
  EMU_EM01Init_TypeDef em01Init = EMU_EM01INIT_DEFAULT;
  EMU_EM01Init(&em01Init);
#endif // EMU_VSCALE_PRESENT
  // Set up EM2, EM3 energy mode configuration
  EMU_EM23Init_TypeDef em23init = EMU_EM23INIT_DEFAULT;
#if defined(EMU_VSCALE_PRESENT)
  em23init.vScaleEM23Voltage = emuVScaleEM23_LowPower;
#endif // EMU_VSCALE_PRESENT
  EMU_EM23Init(&em23init);

{% if is_arch_xg22 %}
// CAUTION! With the line below, EM2 enters Debug Mode to support development.
// Removing that line will lower power draw but also makes further flashing and
// debugging impossible while in EM2 sleep!
// To remedy this, set the WSTK switch next to the battery holder to USB (powers
// down the EFR). Execute Simplicity Commander with command line parameters:
// "./commander.exe device recover"
// and then immediately move the switch to the AEM postion. An additional
// "./commander.exe device masserase"
// command completes the recovery procedure.
  EMU->CTRL |= EMU_CTRL_EM2DBGEN;
{% endif %}

#if defined(RMU_PRESENT)
  // Set reset mode for sysreset back to DEFAULT (extended), this might have
  // been changed by the bootloader to FULL reset.
  RMU->CTRL = (RMU->CTRL & ~_RMU_CTRL_SYSRMODE_MASK) | RMU_CTRL_SYSRMODE_DEFAULT;
#endif

{% if is_arch_xg11 %}
  TEMPDRV_Init();
{% endif %}
}

static void initMcu_clocks(void)
{
  // Initialize HFXO
  initHFXO();

  // Set system HFXO frequency
  SystemHFXOClockSet(BSP_CLK_HFXO_FREQ);

{% if "S1_OSCILLATOR" in features %}
  // Enable HFXO oscillator, and wait for it to be stable
  CMU_OscillatorEnable(cmuOsc_HFXO, true, true);

{% endif %}
{% if "S1_CMU" in features %}
  // Enable HFXO Autostart only if EM2 voltage scaling is disabled.
  // In 1.0 V mode the chip does not support frequencies > 21 MHz,
  // this is why HFXO autostart is not supported in this case.
#if!defined(_EMU_CTRL_EM23VSCALE_MASK)
  // Automatically start and select HFXO
  CMU_HFXOAutostartEnable(0, true, true);
#else
  CMU_ClockSelectSet(cmuClock_HF, cmuSelect_HFXO);
#endif//_EMU_CTRL_EM23VSCALE_MASK

{% endif %}
{% if "S1_OSCILLATOR" in features %}
  // HFRCO not needed when using HFXO
  CMU_OscillatorEnable(cmuOsc_HFRCO, false, false);

{% endif %}
{% if "S1_CMU" in features %}
  // Enabling HFBUSCLKLE clock for LE peripherals
  CMU_ClockEnable(cmuClock_HFLE, true);

{% endif %}
{% if "S2_CMU" in features %}
  {% if is_arch_xg21 %}
  CMU_HFRCODPLLBandSet(cmuHFRCODPLLFreq_80M0Hz);
  CMU_ClockSelectSet(cmuClock_SYSCLK, cmuSelect_HFRCODPLL);
  {% else %}
  CMU_ClockSelectSet(cmuClock_SYSCLK, cmuSelect_HFXO);
  {% endif %}
{% endif %}

{# PLFRCO only exists on xG13 #}
{% if is_arch_xg13 %}
  // To use PLFRCO, uncomment the following block and remove the LFXO lines if they are present.
  // When using PLFRCO, be sure to have .bluetooth.sleep_clock_accuracy set to 500 (ppm)
//  #if defined(PLFRCO_PRESENT)
//    /* Ensure LE modules are accessible */
//    CMU_ClockEnable(cmuClock_CORELE, true);
//    /* Enable PLFRCO as LFECLK in CMU (will also enable oscillator if not enabled) */
//    CMU_ClockSelectSet(cmuClock_LFA, cmuSelect_PLFRCO);
//    CMU_ClockSelectSet(cmuClock_LFB, cmuSelect_PLFRCO);
//    CMU_ClockSelectSet(cmuClock_LFE, cmuSelect_PLFRCO);
//  #endif
{% endif %}
{% if "LFXO" in features %}
  // Initialize LFXO
  CMU_LFXOInit_TypeDef lfxoInit = BSP_CLK_LFXO_INIT;
  {% if "S1_CTUNE" in features %}
  lfxoInit.ctune = BSP_CLK_LFXO_CTUNE;
  {% elif "S2_CTUNE" in features %}
  lfxoInit.capTune = BSP_CLK_LFXO_CTUNE;
  {% endif %}
  CMU_LFXOInit(&lfxoInit);
  // Set system LFXO frequency
  SystemLFXOClockSet(BSP_CLK_LFXO_FREQ);
{% elif is_part_only %}
  #warning "WARNING: Use the CMU_LFXOInit() function only if the LFXO hardware is actually present!"
  // Initialize LFXO
  //CMU_LFXOInit_TypeDef lfxoInit = BSP_CLK_LFXO_INIT;
  {% if "S1_CTUNE" in features %}
  //lfxoInit.ctune = BSP_CLK_LFXO_CTUNE;
  {% elif "S2_CTUNE" in features %}
  //lfxoInit.capTune = BSP_CLK_LFXO_CTUNE;
  {% endif %}
  //CMU_LFXOInit(&lfxoInit);
  // Set system LFXO frequency
  //SystemLFXOClockSet(BSP_CLK_LFXO_FREQ);

{% endif %}
{% if "LFXO" in features %}
  {% if "S1_CMU" in features %}
{{ '  #warning "WARNING: Make sure LFXO is present on the actual hardware when using it as a clock source!"' if is_chip_only }}
  // Set LFXO if selected as LFCLK
  {{'//' if is_chip_only }}CMU_ClockSelectSet(cmuClock_LFA, cmuSelect_LFXO);
  {{'//' if is_chip_only }}CMU_ClockSelectSet(cmuClock_LFB, cmuSelect_LFXO);
  {{'//' if is_chip_only }}CMU_ClockSelectSet(cmuClock_LFE, cmuSelect_LFXO);
  {% elif "S2_CMU" in features %}
{{ '  #warning "WARNING: Make sure LFXO is present on the actual hardware when using it as a clock source!"' if is_part_only }}
  // Select LFXO as low frequency clock source
  {{'//' if is_part_only }}CMU_ClockSelectSet(cmuClock_RTCC, cmuSelect_LFXO);
  {{'//' if is_part_only }}CMU_ClockSelectSet(cmuClock_EM23GRPACLK, cmuSelect_LFXO);
  {{'//' if is_part_only }}CMU_ClockSelectSet(cmuClock_EM4GRPACLK, cmuSelect_LFXO);
  {{'//' if is_part_only }}CMU_ClockSelectSet(cmuClock_WDOG0, cmuSelect_LFXO);
    {% if not is_arch_xg22 %}
  {{'//' if is_part_only }}CMU_ClockSelectSet(cmuClock_WDOG1, cmuSelect_LFXO);
    {% endif %}

  {% endif %}
{% else %}
  {# LFRCO with High Precision Mode only exists on xG22 #}
  {% if is_arch_xg22 %}
  // Select LFRCO as low frequency clock source
  // When using LFRCO, be sure to have .bluetooth.sleep_clock_accuracy set to 500 (ppm)
  CMU_ClockSelectSet(cmuClock_RTCC, cmuSelect_LFRCO);
  CMU_ClockSelectSet(cmuClock_EM23GRPACLK, cmuSelect_LFRCO);
  CMU_ClockSelectSet(cmuClock_EM4GRPACLK, cmuSelect_LFRCO);
  CMU_ClockSelectSet(cmuClock_WDOG0, cmuSelect_LFRCO);
  CMU_LFRCOSetPrecision(cmuPrecisionHigh);
  {% endif %}

{% endif %}
}

static void initHFXO(void)
{
  // Initialize HFXO
  // Use BSP_CLK_HFXO_INIT as last result (4th)
  CMU_HFXOInit_TypeDef hfxoInit = BSP_CLK_HFXO_INIT;
  // if Factory Cal exists in DEVINFO then use it above all (1st)
  if (0 == (DEVINFO->MODULEINFO & DEVINFO_MODULEINFO_HFXOCALVAL_MASK)) {
#if defined(_SILICON_LABS_32B_SERIES_1)
    set_HFXO_CTUNE(DEVINFO_MODULEINFO_CRYSTALOSCCALVAL);
#elif defined(_SILICON_LABS_32B_SERIES_2)
    set_HFXO_CTUNE(DEVINFO->MODXOCAL & _DEVINFO_MODXOCAL_HFXOCTUNEXIANA_MASK);
#endif
  }
  // if User page has CTUNE from studio use that in 2nd place
#if (MFG_CTUNE_EN == 1)
  else if (MFG_CTUNE_VAL != 0xFFFF) {
    set_HFXO_CTUNE(MFG_CTUNE_VAL);
  }
#endif
  // 3rd option, get data from header defined for product/board
#if defined(BSP_CLK_HFXO_CTUNE) && BSP_CLK_HFXO_CTUNE >= 0
  else {
    set_HFXO_CTUNE(BSP_CLK_HFXO_CTUNE);
  }
#endif
  CMU_HFXOInit(&hfxoInit);
}
